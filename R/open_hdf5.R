# open_hdf5.R
# module contains:
#  1. unpack_hdf5()
#  2. unpack_hdf5s()
#  3. get_data_subset()

# Code to open hdf5 created by extract.R
#' unpack_hdf5
#'
#' @param hdf5_path to a single hdf5 file creates by extract.R
#'
#' @return a list containing the data objects within the hdf5
#' @export
#'
#' @examples
unpack_hdf5 <- function(hdf5_path, add_batch = TRUE){

  h    = hdf5r::h5file(hdf5_path, mode= 'r' )
  #h$ls(recursive = T)
  pos_       <-  h[['data/pos']][,]
  fi_        <-  h[['data/fi']][,]
  raw_       <-  h[['data/raw']][,]
  col_pos    <-  h[['data/cols_pos']][]
  col_fi     <-  h[['data/cols_fi']][]
  fcs_       <-  h[['data/fcs_index']][]
  trw_       <-  h[['data/transform_wide']][]
  trl_       <-  h[['data/transform_long']][]
  colnames(pos_) <- col_pos
  colnames(fi_)  <- col_fi
  colnames(raw_)  <- col_fi
  h$close_all()
  
  if (add_batch){
    batch = basename(hdf5_path)
    fcs_[['batch']]<- batch
  }
  
  return(list(fcs = fcs_,
              pos = pos_, 
              fi = fi_, 
              raw = raw_,
              trw = trw_,
              trl = trl_))
}

#' unpack_hdf5s
#'
#' @param paths list of paths to hdf5 files from the same project group
#'
#' @returna a list containing the data objects within the hdf5 concatenated 
#' across the project
#' @export
#'
#' @examples
unpack_hdf5s <-function(paths, add_batch= TRUE){
  x = purrr::map(paths, ~unpack_hdf5(.x, add_batch = add_batch))
  pos_ <- do.call(rbind, purrr::map(x, ~.x[['pos']]))
  fi_  <- do.call(rbind, purrr::map(x, ~.x[['fi']]))
  raw_ <- do.call(rbind, purrr::map(x, ~.x[['raw']]))
  fcs_ <- do.call(rbind, purrr::map(x, ~.x[['fcs']]))
  trw_ <- do.call(rbind, purrr::map(x, ~.x[['trw']]))
  trl_ <- do.call(rbind, purrr::map(x, ~.x[['trl']]))
  
  
  return(list(fcs  = fcs_,
              pos = pos_, 
              fi  = fi_, 
              raw = raw_, 
              trw = trw_,
              trl = trl_))
}

#' get_data subset
#'
#' @param X unpacked hdf5 list containing fcs, pos, fi, raw dataframes
#' @param frac percent of each of sample to select
#' @param seed integer to set random seed
#'
#' @return list with sub sampled dataframes of matching dimensions
#' @export
#'
#' @examples
get_data_subset <- function(data, 
                            ptid_visit_exclude = NULL, 
                            frac = 0.1, 
                            seed = 1 ){
  set.seed(seed)
  if (!is.null(ptid_visit_exclude)){
    subx = data$fcs_ptid %>% 
      dplyr::mutate(ptid_visit = paste0(ptid, "_", visit)) %>%
      dplyr::filter(!ptid_visit %in% ptid_visit_exclude) %>%
      dplyr::group_by(sample_name) %>% 
      dplyr::sample_frac(., size = frac, replace = F) %>% 
      dplyr::arrange(sample_name, cell) %>% 
      dplyr::select(cell, sample_name) %>% 
      dplyr::mutate(subsample = 1)
  }else{
    subx = data$fcs_ptid %>% 
      dplyr::group_by(sample_name) %>% 
      dplyr::sample_frac(., size = frac) %>% 
      dplyr::arrange(sample_name, cell) %>% 
      dplyr:: select(cell, sample_name) %>% 
      dplyr::mutate(subsample = 1)
  }
  
  ix = data$fcs %>% left_join(subx,  by = c("cell", "sample_name") ) %>% 
    mutate(subsample = ifelse(is.na(subsample),0, subsample)) %>%
    pull(subsample) %>% 
    as.logical()
  
  # DEAL WITH CORNER CASES WHERE WE WANT TO AVOID SAMPLE LOSS
    # Make sure index of dummies are saved no matter what fraction is sampled
  ix_dummy = data$fcs$dummy == 1
  # ix - subset index if true for any of these criteria
  ix = ix|ix_dummy
  
  return(list(fcs      = data$fcs[ix,],
              fcs_ptid = data$fcs_ptid[ix,],
              pos      = data$pos[ix,], 
              fi       = data$fi[ix,], 
              raw      = data$raw[ix,]))
}


#' unpack_data_hdf5 
#' 
#' Unpacks a data hdf5 containing information combined across batches
#' This .h5 is generated by the process compile_flow_events.R
#'
#' @param hdf5_path - string specifying file path
#'
#' @return list containiing, fcs_ptid (data.frame), fcs (data.frame), 
#' pos (matrix), fi (matrix), and raw (matrix)
#' @export
#'
#' @examples
unpack_data_hdf5 <- function(hdf5_path){
  h    = hdf5r::h5file(hdf5_path, mode= 'r' )
  #h$ls(recursive = T)
  pos_       <-  h[['data/pos']][,]
  fi_        <-  h[['data/fi']][,]
  raw_       <-  h[['data/raw']][,]
  col_pos    <-  h[['data/cols_pos']][]
  col_fi     <-  h[['data/cols_fi']][]
  fcs_       <-  h[['data/fcs']][]
  fcs_ptid_  <-  h[['data/fcs_ptid']][]
  all_samples_     <-  h[['data/all_samples']][]
  subset_samples_  <-  h[['data/subset_samples']][]
  colnames(pos_) <- col_pos
  colnames(fi_)  <- col_fi
  colnames(raw_)  <- col_fi
  h$close_all()
  return(list(fcs_ptid = fcs_ptid_,
              fcs = fcs_,
              pos = pos_, 
              fi = fi_,
              raw = raw_,
              all_samples = all_samples_,
              subset_samples = subset_samples_))
}

#' unpack_umap_hdf5 
#' 
#' Unpacks a data hdf5 containing information about umap
#' this .h5 is generated by the process compile_flow_events.R
#' if the --umap flag is set true
#'
#' @param hdf5_path - string specifying file path
#'
#' @return list containing : coordinates, and fcs_ptid dataframe
#' @export
#'
#' @examples
unpack_umap_hdf5 <- function(hdf5_path){
  
  h    = hdf5r::h5file(hdf5_path, mode= 'r' )
  h$ls(recursive = T)
  coordinates_ <-  h[['umap/coordinates']][,]
  fcs_ptid_    <-  h[['umap/fcs_ptid']][]
  return(list(coordinates = coordinates_,
              fcs_ptid    = fcs_ptid_))
  
}

#' unpack_cluster_hdf5 
#' 
#' Unpacks a data hdf5 containing information about umap
#' this .h5 is generated by the process compile_flow_events.R
#' if the --cluster or --cluster_annoy options are selected
#'
#' @param hdf5_path 
#'
#' @return list containing : membership, names, fcs_ptid
#' @export
#'
#' @examples
unpack_cluster_hdf5 <- function(hdf5_path){
  
  h    = hdf5r::h5file(hdf5_path, mode= 'r' )
  h$ls(recursive = T)
  membership_ <-  h[['clustering/membership']][]
  names_     <-   h[['clustering/names']][]
  fcs_ptid_  <-   h[['clustering/fcs_ptid']][]
  return(list(membership  = membership_,
              names       = names_,
              fcs_ptid    = fcs_ptid_))
  
}

#' unpack_summary_hdf5 
#' 
#' Unpacks a data hdf5 containing information about umap
#' this .h5 is generated by the process compile_flow_events.R
#' if the --cluster or --cluster_annoy options are selected
#'
#' @param hdf5_path 
#'
#' @return list containing : membership, names, fcs_ptid
#' @export
#'
#' @examples
unpack_summary_hdf5 <- function(hdf5_path){
  
  h    = hdf5r::h5file(hdf5_path, mode= 'r' )
  h$ls(recursive = T)
  summary_ <-  h[['summary/results']][]
  fcs_ptid_cluster_  <-  h[['summary/fcs_ptid_cluster']][]
  return(list(summary = summary_,
              fcs_ptid_cluster = fcs_ptid_cluster_))
}



is_list_not_null <- function(input_list) {
  if (!is.null(input_list) && length(input_list) > 0) {
    return(TRUE)
  } else {
    return(FALSE)
  }
}


# h = hdf5r::h5file(hdf5_path_results,
#                   mode= 'r' )
# summary = list()
# sample_summary   = hr[['summary/results']][]
# if(use_clusters){
#   events         = hr[['summary/fcs_ptid_cluster']][]
# }else{
#   events         = hr[['summary/fcs_ptid']][]
# }
# summary$results = results
# summary$events  = events 
# h$close_all()
# return(summary)

